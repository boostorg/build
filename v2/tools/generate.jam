# Copyright 2006 Vladimir Prus 
# Distributed under the Boost Software License, Version 1.0. 
# (See accompanying file LICENSE_1_0.txt or http://www.boost.org/LICENSE_1_0.txt) 

# Declares main target 'generate' that can be used to produce targets
# by calling a user-provides rule, that takes virtual target and produces
# virtual target.

import targets ;
import "class" : new ;
import property ;
import errors : error ;
import type : type ;
import regex ;
import property-set ;
import project ;
import feature ;

feature.feature generating-rule : : free ;


class generated-target-class : basic-target
{
    import errors ;
    import indirect ;
    import virtual-target ;
    
    rule __init__ ( name : project : sources * : requirements *
        : default-build * : usage-requirements * )
    {     
        basic-target.__init__ $(name) : $(project) : $(sources) 
          : $(requirements) : $(default-build) : $(usage-requirements) ;
        
        local r = [ $(self.requirements).get <generating-rule> ] ;
        if ! $(r)
        {
            errors.user-error 
              "The generate rule requires <generating-rule> property to be set" ;            
        }        
    }
        
    rule construct ( name : sources * : property-set )
    {
        local result ;
        local gr = [ $(property-set).get <generating-rule> ] ;
        
        # FIXME: this is copy-paste from virtual-target.jam. Must
        # have an utilty rule to call a rule like this.
        local rule-name = [ MATCH ^@(.*) : $(gr) ] ;
        if $(rule-name)
        {
            if $(tag[2])
            {
                errors.error "<tag>@rulename is present but is not the only <tag> feature" ;
            }
           
                
            result = [ indirect.call $(rule-name) $(self.project) $(name) 
              : $(property-set) : $(sources) ] ;
            
            if ! $(result)
            {
                ECHO "warning: Unable to construct" [ full-name ] ;
            }            
        }    
        
        local ur ;
        local targets ;

        if $(result)
        {            
            if  [ class.is-a $(result[1]) : property-set ]
            {
                ur = $(result[1]) ;
                targets = $(result[2-]) ;
            }
            else
            {
                ur = [ property-set.empty ] ;
                targets = $(result) ;
            }       
        }        
        local rt ;
        for t in $(targets)
        {
            rt += [ virtual-target.register $(t) ] ;
        }
        return $(ur) $(rt) ;
    }   
}

rule generate ( name : sources * : requirements * : default-build * 
    : usage-requirements * )
{
    local project = [ project.current ] ;
        
    targets.main-target-alternative
     [ new generated-target-class $(name) : $(project)
       : [ targets.main-target-sources $(sources) : $(name) ] 
       : [ targets.main-target-requirements $(requirements) : $(project) ] 
       : [ targets.main-target-default-build $(default-build) : $(project) ]
       : [ targets.main-target-usage-requirements $(usage-requirements) : $(project) ]
     ] ;         
}

IMPORT $(__name__) : generate : : generate ;



<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//Boost//DTD BoostBook XML V1.0//EN"
  "http://www.boost.org/tools/boostbook/dtd/boostbook.dtd">

  <chapter id="bbv2.advanced">
    <title>User documentation</title>

  <para>This section will provide the information necessary to create your own
  projects using Boost.Build. The information provided here is relatively
  high-level, and <link linkend="bbv2.reference">detailed reference</link> as
  well as the on-line help system must be used to obtain
  low-level documentation (see the <link linkend=
  "bbv2.reference.init.options.help">help option</link>).</para>

  <para>The Boost.Build actually consists of two parts - Boost.Jam, which is a
  build engine with its own interpreted language, and Boost.Build itself,
  implemented in Boost.Jam's language. The chain of event which happen when
  you type "bjam" on the command is:
      <orderedlist>
        <listitem>
          <para>Boost.Jam tries to find Boost.Build and loads the top-level
          module. The exact process is described in the <link
          linkend="bbv2.reference.init">section on
          initialization</link></para>
        </listitem>
        <listitem>
          <para>Boost.Build top-level module loads user-defined configuration
          files, "user-config.jam" and "site-config.jam", which define
          available toolsets.</para>
        </listitem>
        <listitem>
          <para>The Jamfile in the current directory is read. That in turn
          might cause reading of further Jamfiles. As a result, a tree of
          projects is created, with targets inside projects.</para>
        </listitem>
        <listitem>
          <para>Finally, using build request specified on the command line,
          Boost.Build decides which targets should be built, and how. That
          information is passes back to Boost.Jam, which takes care of
          actually running commands.</para>
        </listitem>        
      </orderedlist>
    </para>

    <para>So, to be able to successfully use Boost.Build, you'd need to know only
      three things:
      <itemizedlist>
        <listitem>
          <para><link linkend="bbv2.advanced.configuration">
              How to configure Boost.Build</link></para>
        </listitem>
        <listitem>
          <para><link linkend="bbv2.advanced.jamfiles">
              How to write Jamfiles</link></para>
        </listitem>
        <listitem>
          <para><link linkend="bbv2.advanced.build_process">
              How the build process works</link></para>
        </listitem>
      </itemizedlist>
    </para>
    

  <section id="bbv2.advanced.configuration">
    <title>Configuration</title>

    <para>The Boost.Build configuration is specified in the file
    "user-config.jam". You can edit the one which comes with Boost.Build, or
    create a copy in your home directory and edit that. The primary function
    of that file is to declarate which compilers and other tools are
    available. The simplest syntax to configure a tool is:
<programlisting>
using &lt;tool-name&gt; ;        
</programlisting>
      The "using" rule is given a name of tool, and will make that tool
      available to Boost.Build. For example, "using gcc ;" will make available
      the gcc compiler.      
    </para>

    <para>
      Since nothing but tool name is specified, Boost.Build will pick some
      default settings -- for example will use gcc found in path, or look in
      some known installation locations. For ordinary users, this is quite
      fine. In case you have several version of a compiler, or it's located in
      some unusual location, or you need to tweak the configuration, you'd
      need to pass additional parameters to the "using" rule. Generally, 
      for every tool module, the parameters differ, and you can obtain the documentaiton
      by running
<programlisting>
bjam --help &lt;tool-name&gt;.init         
</programlisting>
      on the command line. However, for all compilers the meaning of two first
      parameters is the same: version and invocation command.
    </para>

    <para>The "version" parameter identifies the compiler, in case you have
    several. It can have any form you like, but it's recommended that you use
    numeric identifier, like &quot;7.1&quot;. The "invocation command"
    parameter is the command which must be executed to run the compiler. This
    might be just compiler name, or a name with a path in it. Here are some
    examples. 
    </para>
      
    <para>To configure a compiler installed in non-standard location and not
    present in path, you can do the following:
<programlisting>
using msvc : : Z:/Programs/Microsoft Visual Studio/vc98/bin/cl.exe ;
</programlisting>
    </para>

    <para>To configure several versions of a compiler, the following can be used.
<programlisting>
using gcc : 3.3 ;
using gcc : 3.4 : g++-3.4 ;
using gcc : 3.2 : g++-3.2 ;
</programlisting>
        Note that in the first call to "using", the compiler found in path
      will be used, and there's ne need to explicitly specify the command.
    </para>

    <para>As shown above, both "version" and "invocation command" parameters
    are optional, but there's important restriction: if you configure the same
    compiler more then once, you must pass the "version" parameter every
    time. For example, the following is not allowed:
<programlisting>
using gcc ;
using gcc : 3.4 : g++-3.4 ;
</programlisting>
      because the first "using" does not specify the version. 
    </para>
                
    </section>

  <section id="bbv2.advanced.jamfiles">
    <title>Writing Jamfiles</title>

    <section id="bbv2.advanced.overview">
      <title>Overview</title>

      <para>Jamfiles are the thing which is most important to the user,
      bacause they declare the targets which should be build. Jamfiles are
      also used for organizing targets -- each Jamfile is a separate project,
      which can be build independently from the other projects.</para>

      <para>Jamfile mostly contain calls to Boost.Build functions, which do
        all the work, specifically:
        <itemizedlist>
          <listitem>
            <para><link linkend="bbv2.advanced.targets">declare main
                targets</link></para>
          </listitem>
          <listitem>
            <para><link
            linkend="bbv2.advanced.projects">define
            project properties</link></para>
          </listitem>
          <listitem>
            <para><link linkend="bbv2.advanced.other-rules">do various other
            things</link></para>            
          </listitem>
        </itemizedlist>
      </para>

      <para>In addition to Jamfiles, Boost.Build has another user-editable
        file, project-root.jam, which is mostly usefull to declare constants
        global to all the projects. It is also describe <link
        linkend="bbv2.advanced.project-root">below</link>.
      </para>

<!--
      <para>The most fundemental entity in Boost.Build is <emphasis>main
          target</emphasis>. This is object that user want to construct from
        sources and keep up to date with regard to those sources. Typical
        examples of main targets are executable files and libraries.</para>
      
      <para>Main targets are grouped in <emphasis>projects</emphasis>. Their main
        purpose is organization: related targets placed in one project,
        can then be built together, or share some definitions.</para>
      
      <para>Main targets and projects are created as the result of reading
        one or several Jamfiles. Each Jamfile is a file written in
        Boost.Jam interpreted language, and typically contains calls to
        functions provided by Boost.Build, which create main targets of
        needed type, declare project attributes and access other
        projects. The full list of functions provided by Boost.Build is
        described <link linkend="bbv2.advanced.builtins">below</link>.
        Of course, user can create his own functions, or it can directly
        access Boost.Build internals from Jamfile, if builtin facilities are
        not sufficient.</para>

  <para>Each main target, or project can be built in a number of ways,
  say with optimization or without. We'll call such entities
  "metatargets". To make Boost.Build produce any real targets, user
  issues <link linkend="bbv2.reference.buildreq">build request</link>,
  which specifies metatargets to be built, and properties to be
  used.</para>

  <para>The <emphasis>properties</emphasis> are just (name,value) pairs that
  describe various aspects of constructed objects, for example:</para>
  <programlisting>
&lt;optimization&gt;full &lt;inlining&gt;off
</programlisting>

  <para>Given the built request, Boost.Build figures out the targets
  needed for requested metatargets with requested properties, how
  they can be created, and whether exising files can be reused. It
  finally issues command to create needed files, automatically
  converting properties into appropricate command line options.</para>
-->
    </section>

<!--
    <section id="bbv2.advanced.roadmap">
      <title>Your first project and roadmap</title>


  <para>Creating your first project requires three steps:</para>

  <orderedlist>
    <listitem><simpara>Create an empty file called "Jamfile"</simpara></listitem>

    <listitem>
      <simpara>
        Create an empty file called "project-root.jam"
      </simpara>
    </listitem>

    <listitem>
      <para>Either set your <envar>BOOST_BUILD_PATH</envar> environment
    variant to Boost.Build root, or create a "boost-build.jam" file
    with the following content:

<programlisting>
boost-build /path/to/boost.build ;
</programlisting>

      </para>
    </listitem>
  </orderedlist>

  <para>After that, you can run the "bjam" command in the directory
  where you've created the files. Surely, it won't do anything, but
  it will run without error, at least. Your next steps might
  be:</para>

  <orderedlist>
    <listitem>
      <simpara>
        Adding new main targets to the "Jamfile" file. The basic
    syntax for declaring a main target is described <link linkend=
    "bbv2.advanced.targets">below</link>, and all builtin functions for
    declaring main targets are <link linkend=
    "bbv2.advanced.builtins.targets">listed</link>.
      </simpara>
    </listitem>

    <listitem>
      <simpara>
        Creating subprojects. Create a directory, put new Jamfile
    there, and move some main targets to that Jamfile, or declare
    new ones. The <link linkend="bbv2.advanced.projects">projects
    reference</link> will help with this part.
      </simpara>
    </listitem>

    <listitem>
      <simpara>
        Customizing Boost.Build for your needs. You might have
    additional tools you want to run, or just want different
    extension for some file. The <link linkend="bbv2.extending">extender manual</ulink> is waiting for
    you.
      </simpara>
    </listitem>
  </orderedlist>

    </section>
-->
    <section id="bbv2.advanced.targets">
      <title>Main targets</title>

      <para id="bbv2.advanced.targets.main">
        <emphasis>Main target</emphasis> is a user-defined named
        entity which can be build, for example a named executable file.
        Declaring a main target is usually done using one of <link linkend=
          "bbv2.advanced.builtins.targets">main target functions</link>.
        The user can also declare <ulink url=
          "doc/extending.html#main_target_rules">custom main target
          function</ulink>.</para>
      
      <para>Most main targets rules in Boost.Build use similiar
        syntax:</para>

<anchor id="bbv2.main-target-rule-syntax"/>
<programlisting>
function-name main-target-name 
    : sources 
    : requirements 
    : default-build 
    : usage-requirements 
    ;
</programlisting>

      <itemizedlist>
        <listitem>
          <simpara>
            "main-target-name" is the name used to request the target
            on command line and to use it from other main targets. Main
            target name may contain alphanumeric characters and symbols '-'
            and '_';
          </simpara>
        </listitem>
        
        <listitem>
          <simpara>
            "sources" is the list of source files and other main
            targets that must be combined. 
          </simpara>
        </listitem>
        
        <listitem>
          <simpara>
            "requirements" is the list of properties that must always
            be present when this main target is built.
          </simpara>
        </listitem>
        
        <listitem>
          <simpara>
            "default-build" is the list of properties that will be used
            unless some other value of the same feature is already
            specified.
          </simpara>
        </listitem>
        
        <listitem>
          <simpara>
            "usage-requirements" is the list of properties that will be
            propagated to all main targets that use this one, i.e. to all
            dependedents.
          </simpara>
        </listitem>
      </itemizedlist>

      <para>Some main target rules have shorter list of parameters, and
        you should consult their documentation for details.</para>
      
      <para>The list of sources specifies what should be processed to get
        the resulting targets. Most of the time, it's just a list of
        files. Sometimes, you'd want to use all files with the same
        extension as sources, in which case you can use the "glob"
        rule. Here are two examples:
<programlisting>
exe a : a.cpp ;
exe b : [ glob *.cpp ] ;
</programlisting>
        Unless you specify a files with absolute path, the name is
        considered relative to the source directory -- which is typically
        the same as directory when Jamfile is located, but can be changed as
        described <link linkend=
          "bbv2.advanced.projects.attributes.projectrule">here</link>
      </para>
      
      <para>
        The list of sources can also reference other main targets. The
        targets in the same project can be referred by using the name, and
        targets in other project need to specify directory or a symbolic
        name of the other project. For example:
<programlisting>
lib helper : helper.cpp ;
exe a : a.cpp helper ;
exe b : b.cpp ..//utils ;
exe c : c.cpp /boost/program_options//program_opions ;
</programlisting>
        The first exe uses the library defined in the same project. The
        second one uses some target (most likely library) defined by Jamfile
        one level higher. Finally, the third target uses some <ulink
          url="http://boost.org">C++ Boost</ulink> library, using the
        symbolic name to refer to it. More information about it can be found
        in <link linkend="bbv2.tutorial.libs">tutorial</link> and in 
        <link linkend="bbv2.reference.ids">target id reference</link>.          
      </para>

<!--
      <section id="bbv2.advanced.targets.requirements">        
        <title>Requirements and usage-requirements</title>
        
        <para>The requirements argument specify what properties are absolutely
        necessary for this main target. 
      </section>
-->

      <para>Building of the same main target can differ greatly from
        platform to platform. For example, you might have different list
        of sources for different compilers, or different options for those
        compilers. Two approaches to this are explained in the 
        <link linkend="bbv2.tutorial.conditions">tutorial</link>.
      </para>

      <para>Sometimes a main target is really needed only by some other
        main target. E.g. a rule that declares test-suite uses a main
        target that represent test, but those main targets are rarely
        needed by themself.</para>

      <para>It possible to declare target inline, i.e. the "sources"
        parameter may include call to other main rules. For example:</para>

<programlisting>
exe hello : hello.cpp 
    [ obj helpers : helpers.cpp : &lt;optimization&gt;off ] ;
</programlisting>

      <para>
        Will cause "helpers.cpp" to be always compiled without
        optimization. It's possible to request main targets declared
        inline, but since they are considered local, they are renamed to
        "parent-main-target_name..main-target-name". In the example above,
        to build only helpers, one should run "bjam hello..helpers".
      </para>

    </section>

    <section id="bbv2.advanced.projects">
      <title>Projects</title>

      <para>As mentioned before, targets are grouped into project, and each
        Jamfile is a separate project. Projects are usefull because it allows
        to group related targets together, define properties common to all
        those targets, and assign a symbolic name to the project, allowing to
        easily refer to the targets in the project. Two last goals are
        accompished with the "project" rule.
      </para>

      <para>The rule has this syntax
<programlisting>
project id : &lt;attributes&gt; ;
</programlisting>
        Here, attributes is a sequence of (attribute-name,
        attribute-value) pairs. The list of attribute names along with its
        handling is also shown in the table below. For example, it it
        possible to write:
<programlisting>
project tennis 
    : requirements &lt;threading&gt;multi 
    : default-build release
    ;
</programlisting>   
      </para>

      <para>The possible attributes are listed below.</para>

      <para><emphasis>Project id</emphasis> is a short way to denote a project, as
        opposed to the Jamfile's pathname. It is a hierarchical path,
        unrelated to filesystem, such as "boost/thread". <link linkend=
          "bbv2.reference.ids">Target references</link> make use of project ids to
        specify a target.</para>

      <para><emphasis>Source location</emphasis> specifies the directory where sources
        for the project are located.</para>

      <para><emphasis>Project requirements</emphasis> are requirements that apply to
        all the targets in the projects as well as all subprojects.</para>

      <para><emphasis>Default build</emphasis> is the build request that should be
        used when no build request is specified explicitly.</para>

      <para id="bbv2.advanced.projects.attributes.projectrule">
        The default values for those attributes are
        given in the table below.

        <table>
          <title/>
          <tgroup cols="4">
            <thead>
              <row>
                <entry>Attribute</entry>
                
                <entry>Name for the 'project' rule</entry>
                
                <entry>Default value</entry>
                
                <entry>Handling by the 'project' rule</entry>
              </row>
            </thead>
            
            <tbody>
              
              <row>
                <entry>Project id</entry>
                
                <entry>none</entry>
                
                <entry>none</entry>
                
                <entry>Assigned from the first parameter of the 'project' rule.
                  It is assumed to denote absolute project id.</entry>
              </row>
              
              <row>
                <entry>Source location</entry>
                
                <entry><literal>source-location</literal></entry>
                
                <entry>The location of jamfile for the project</entry>
                
                <entry>Sets to the passed value</entry>
              </row>
              
              <row>
                <entry>Requirements</entry>
                
                <entry><literal>requirements</literal></entry>
                
                <entry>The parent's requirements</entry>
                
                <entry>The parent's requirements are refined with the passed
                  requirement and the result is used as the project
                  requirements.</entry>
              </row>
              
              <row>
                <entry>Default build</entry>
                
                <entry><literal>default-build</literal></entry>
                
                <entry>none</entry>
                
                <entry>Sets to the passed value</entry>
              </row>
              
              <row>
                <entry>Build directory</entry>
                
                <entry><literal>build-dir</literal></entry>
                
                <entry>If parent has a build dir set, the value of it, joined
                  with the relative path from parent to the current project.
                  Otherwise, empty</entry>
                
                <entry>Sets to the passed value, interpreted as relative to the
                  project's location.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        </para>
      </section>

    <section id="bbv2.advanced.other-rules">
      <title>Additional Jamfile rules</title>

      <para>There's a number of other helper rules which can be used in
      Jamfile, described in the following table.</para>

      <table>
        <title/>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Rule</entry>
              
              <entry>Semantic</entry>
            </row>
          </thead>
          
          <tbody>
            <row>
              <entry><link linkend=
                  "bbv2.advanced.projects.attributes.projectrule">project</link>
              </entry>
              
              <entry>Define project attributes.</entry>
            </row>
            
            <row>
              <entry><link linkend=
                  "bbv2.advanced.projects.relationships.useprojectrule">use-project</link></entry>
              
              <entry>Make another project known.</entry>
            </row>
            
            <row>
              <entry><link linkend=
                  "bbv2.advanced.projects.relationships.buildprojectrule">build-project</link></entry>
              
              <entry>Build another project when this one is built.</entry>
            </row>
            
            <row>
              <entry><link linkend=
                  "bbv2.reference.buildprocess.explict">explicit</link></entry>
              
              <entry>States that the target should be built only by explicit
                request.</entry>
            </row>
            
            <row>
              <entry>glob</entry>
              
              <entry>Takes a list of wildcards, and returns the list of files
                which match any of the wildcards.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
      
    <section id="bbv2.advanced.project-root">
      <para>Each project is also associated with <emphasis>project root</emphasis>.
        That's a root for a tree of projects, which specifies some global
        properties.</para>
      
        <title>Project root</title>

        <para>
          Project root for a projects is the nearest parent directory
          which contains a file called
          <filename>project-root.jam</filename>. That file defines
          certain properties which apply to all projects under project
          root. It can:

        <itemizedlist>
          <listitem>
            <simpara>
              configure toolsets, via call to <literal>toolset.using</literal>
            </simpara>
          </listitem>
          
          <listitem>
            <simpara>
              refer to other projects, via the <literal>use-project</literal>
              rule
            </simpara>
          </listitem>
          
          <listitem>
            <simpara>
              declare constants, via the <literal>constant</literal> and
              <literal>path-constant</literal> rules.
            </simpara>
          </listitem>
        </itemizedlist>

      </para>

      <para>To facilitate declaration of simple projects, Jamfile and
        project-root can be merged together. To achieve this effect, the
        project root file should call the <literal>project</literal> rule. The
        semantic is precisely the same as if the call was made in
        Jamfile, except that project-root.jam will start serve as
        Jamfile. The Jamfile in the directory of project-root.jam will be
        ignored, and project-root.jam will be able to declare main
        targets as usual.</para>
      
    </section>

<!--
      <section id="bbv2.advanced.projects.relationships">
        <title>Project relationship</title>

  <para>There are three kinds of project relationships.</para>

  <para>First is parent-child. This relationship is established
  implicitly: parent directories of a project are searched, and the
  first found Jamfile is assumed to define the parent project. The
  parent-child relationship affects only attribute values for the
  child project.</para>

  <para id="bbv2.advanced.projects.relationships.buildprojectrule">
  Second is build relationship. Some
  project may request to recursively build other projects. Those
  project need not be child projects. The <literal>build-project</literal>
  rule is used for that:</para>
  <programlisting>
    build-project src ;   
</programlisting>

  <para id="bbv2.advanced.projects.relationships.useprojectrule">
  The third kind is the 'use'
  relationship. In means that one project uses targets from
  another. It is possible to just refer to target in other projects
  using target id. However, if target id uses project id, it is
  required that the project id is known. The
  <literal>use-project</literal>
  rule is employed to guarantee that.
  </para>

<programlisting>
use-project ( id : location )
</programlisting>

        <para>
It loads the project at the specified location, which makes
its project id available in the project which invokes the rule. It
is required that the <literal>id</literal> parameter passed to the
<literal>use-project</literal> rule be equal to the id that the loaded
project declared. At this moment, the <literal>id</literal> paremeter
should be absolute project id.
        </para>
      </section>
    </section>

-->
       
  </section>
  
  <section id="bbv2.advanced.build_process">
    <title>Build process</title>

  <para>This section will describe two things: how you specify what to build,
    and how the main targets are actually build. 
  </para>

  <para>
    The command line specifies which targets to built and which what
    properties. For example:
<programlisting>
bjam app1 lib1//lib1 toolset=gcc variant=debug optimization=full
</programlisting>
    would build two targets, "app1" and "lib1//lib1" with the specified
    properties. You can refer to any targets, using 
    <link linkend="bbv2.reference.ids">target id</link> and specify arbitrary
    properties. Some of the properties are very common, and for them the name
    of the property can be omitted. For example, the above can be written as:
<programlisting>
bjam app1 lib1//lib1 gcc debug optimization=full
</programlisting>
    The complete syntax which had some additional shortcuts if described <link
    linkend="bbv2.reference.commandline">here</link>.
  </para>

  </section>

  <section id="bbv2.advanced.builtins.targets">
    <title>Builtin target types</title>

    <section>
      <title>Programs</title>

      <para>Programs are created using the <code>exe</code> rule, which
        follows the <link linkend="bbv2.main-target-rule-syntax">common
          syntax</link>. For example:
<programlisting>
exe hello : hello.cpp some_library.lib /some_project//library 
          : &lt;threading&gt;multi 
          ;
</programlisting>
        This will create an executable file from the sources -- in this case,
        one C++ file, one library file present in the same directory, and
        another library which is created by Boost.Build. Generally, sources
        can include C and C++ files, object files and libraries. Boost.Build
        will automatically try to convert targets of other types.
      </para>

      <tip>
        <para>         
          On Windows, if an application which uses dynamic libraries, and both
          the application and the libraries are built by Boost.Build, its not
          possible to immediately run the application, because the
          <literal>PATH</literal> environment variable should include the path
          to the libraries. It means you have to either add the paths
          manually, or place the application and the libraries to the same
          directory, for example using the <link
          linked="bbv2.builtin.stage">stage</link> rule.
      </para>
      </tip>
    </section>

    <section>
      <title>Libraries</title>

      <para>Libraries are created using the <code>lib</code> rule, which
        follows the <link linkend="bbv2.main-target-rule-syntax">common
          syntax</link>. For example:
<programlisting>
lib helpers : helpers.cpp : &lt;include&gt;boost : : &lt;include&gt;. ;
</programlisting>
      </para>

      <para>In the most common case, the <code>lib</code> creates a library
        from the specified sources. Depending on the value of
        &lt;link&gt; feature the library will be either static or
        shared. There are two other cases. First is when the library is
        installed somewhere in compiler's search paths, and should be
        searched by the compiler (typically, using the <option>-l</option>
        option). The second case is where the library is available as a 
        prebuilt file and the full path is known.          
        </para>
      
      <para>
        The syntax for these case is given below:
<programlisting>
lib z : : &lt;name&gt;z &lt;search&gt;/home/ghost ;            
lib compress : : &lt;file&gt;/opt/libs/compress.a ;
</programlisting>
        The <code>name</code> property specifies the name which should be
        passed to the <option>-l</option> option, and the <code>file</code>
        property specifies the file location. The <code>search</code> feature
        specifies paths where the library should be searched. That feature can
        be specified several time, or can be omitted -- in which case only
        default compiler paths will be searched.
      </para>
      
      <para>
        For convenience, the following syntax is allowed:
<programlisting>
lib z ;
lib giu db aux ;
</programlisting>
          and is does exactly the same as:
<programlisting>
lib z : : &lt;name&gt;z ;            
lib giu : : &lt;name&gt;gui ;            
lib db : : &lt;name&gt;db ;            
lib aux : : &lt;name&gt;aux ;            
</programlisting>
      </para>
          
      <para>When a library uses another library you should put that another
        library in the list of sources. This will do the right thing in all
        cases. For portability, you should specify library dependencies even
        for searched and prebuilt libraries, othewise, static linking on
        Unix won't work. For example:
<programlisting>
lib z ;
lib png : z : &lt;name&gt;png ;
</programlisting>
        </para>

      <note>
        <para>When a library (say, <code>a</code>), which has another
          library, (say, <code>b</code>) is linked dynamically, the <code>b</code>
          library will be incorporated in <code>a</code>. (If <code>b</code>
          is dynamic library as well, then <code>a</code> will only refer to
          it, and don't include any extra code.) When the <code>a</code>
          library is linked statically, Boost.Build will assure that all
          executables which link to <code>a</code> will also link to
          <code>b</code>.
        </para>
      </note>
         
      <para>One feature of Boost.Build which is very important for libraries
        is usage requirements. For example, if you write:
<programlisting>
lib helpers : helpers.cpp : : : &lt;include&gt;. ;
</programlisting>
        then compiler include path for all targets which use
        <code>helpers</code> will contain the directory where the target is
        defined.path to "helpers.cpp". So, the user need only to add
        <code>helpers</code> to the list of sources, and don't bother about
        other requirements. This allows to greatly simplify Jamfiles.
      </para>

      <note>
        <para>If you don't want shared libraries to include all libraries
          which are specified in sources (especially statically linked ones),
          you'd need to use the following:
<programlisting>
lib b : a.cpp ;
lib a : a.cpp : &lt;use&gt;b : : &lt;library&gt;b ;
</programlisting>
          This specifies that <code>a</code> uses <code>b</code>, and causes
          all executables which link to <code>a</code> also link to
          <code>b</code>. In this case, even for shared linking, the
          <code>a</code> library won't even refer to <code>b</code>.
        </para>
      </note>
          
    </section>

    <section id="bbv2.builtins.alias">
      <title>Alias</title>

      <para>The <code>alias</code> rule follows the <link
          linkend="bbv2.main-target-rule-syntax">common syntax</link>. For
        example:
<programlisting>
alias core : im reader writer ;
</programlisting>
        The sources are returned without any modification.
      </para>

      <para>
        The <code>alias</code> rule is a convenience tool. If you often build
        the same group of targets at the same time, you can define the alias
        to save typing.        
      </para>

      <para>
        Another use of the <code>alias</code> rule is to change build
        properties. For example, if you always want static linking for a
        specific C++ Boost library, you can write the following:
<programlisting>
alias boost_thread : /boost/thread//boost_thread : &lt;link&gt;static ;
</programlisting>
        and use only the <code>boost_thread</code> alias in your Jamfiles.
      </para>               
    </section>


    <section>
      <title>Installing</title>

      <para>For installing the built target you should use the
        <code>stage</code> rule follows the <link
          linkend="bbv2.main-target-rule-syntax">common syntax</link>. For
        example:
<programlisting>
stage dist : hello helpers ;
</programlisting>
        will cause the targets <code>hello</code> and <code>helpers</code> to
        be moved to the <filename>dist</filename> directory. The directory can
        be changed with the <code>location</code> property:
<programlisting>
stage dist : hello helpers : &lt;location&gt;/usr/bin ;
</programlisting>
      </para>

      <para>
        Specifying the names of all libraries to install can be boring. The
        <code>stage</code> allows to specify only the top-level executable
        targets to install, and automatically install all dependencies:
<programlisting>
stage dist : hello 
           : &lt;traverse-dependencies&gt;on &lt;include-type&gt;EXE
             &lt;include-type&gt;LIB
           ;
</programlisting>
        will find all targets that <code>hello</code> depends on, and install
        all of the which are either executables or libraries.
      </para>
        
    </section>

    <section id="bbv2.builtins.testing">

      <title>Testing</title>

      <para>Boost.Build has convenient support for running unit tests. The
        simplest way is the <code>unit-test</code> rule, which follows the
        <link linkend="bbv2.main-target-rule-syntax">common syntax</link>. For
        example:
<programlisting>
unit-test helpers_test : helpers_test.cpp helpers ;
</programlisting>
      </para>

      <para>The <code>unit-test</code> rule behaves like the
        <code>exe</code> rule, but after the executable is created it is
        run. If the executable returns error, the build system will also
        return error and will try running the executable on the next
        invocation until it runs successfully. This behaviour ensures that you
        can't miss a unit test failure.
      </para>

      <para>There are rules for more elaborate testing: <code>compile</code>,
        <code>compile-fail</code>, <code>run</code> and
        <code>run-fail</code>. They are more suitable for automated testing, and
        are not covered here yet.
      </para>        
    </section>
    
  </section>
  
  <section id="bbv2.advanced.builtins.features">
    <title>Builtin features</title> 
        
    <variablelist>
      <varlistentry><term><literal>variant</literal></term>
        
        <listitem>
          <simpara>
            The feature which combines several low-level features in
            order to make building most common variants simple.
          </simpara>
          
          <para><emphasis role="bold">Allowed values:</emphasis> <literal>debug</literal>, <literal>release</literal>,
            <literal>profile</literal></para>
          
          <para>The value <literal>debug</literal> expands to</para>
          
          <programlisting>
            &lt;optimization&gt;off &lt;debug-symbols&gt;on &lt;inlining&gt;off &lt;runtime-debugging&gt;on
          </programlisting>
          
          <para>The value <literal>release</literal> expands to</para>
          
          <programlisting>
            &lt;optimization&gt;speed &lt;debug-symbols&gt;off &lt;inlining&gt;full &lt;runtime-debugging&gt;off
          </programlisting>
          
          <para>The value <literal>profile</literal> expands to the same as
            <literal>release</literal>, plus:</para>
          
          <programlisting>
            &lt;profiling&gt;on &lt;debug-symbols&gt;on
          </programlisting>
          
          <para><emphasis role="bold">Rationale:</emphasis> Runtime debugging is on in debug build
            so suit expectations of people used various IDEs. It's
            assumed other folks don't have any specific expectation in
            this point.</para>
        </listitem></varlistentry>
      
      <varlistentry id="bbv2.advanced.builtins.features.link">
        <term><literal>link</literal></term>
        
        <listitem>
          <simpara>
            Feature which controls how libraries are built.
          </simpara>
          
          <para><emphasis role="bold">Allowed values:</emphasis> <literal>shared</literal>,
            <literal>static</literal></para>
        </listitem></varlistentry>
      
      <varlistentry><term><literal>source</literal></term>
        
        <listitem>
          <simpara>
            Tthe &lt;source&gt;X feature has the same effect on building a target
            as putting X in the list of sources. The feature
            is sometimes more convenient: you can put &lt;source&gt;X in
            the requirements for a project and it will be linked to all
            executables.
          </simpara>
        </listitem>
      </varlistentry>
      
      <varlistentry><term><literal>library</literal></term>
        
        <listitem>
          <simpara>
            This feature is equivalent to the &lt;source&gt; feature, and exists
            for backward compatibility reasons.
          </simpara>
        </listitem>
      </varlistentry>
      
      
      <varlistentry><term><literal>use</literal></term>
        
        <listitem>
          <simpara>
            Causes the target referenced by the value of this feature
            to be constructed and adds it's usage requirements to build
            properties. The constructed targets are not used in any other
            way. The primary use case is when you use some library and want
            it's usage requirements (such as include paths) to be applied,
            but don't want to link to the library.
          </simpara>
        </listitem>
      </varlistentry>
      
      <varlistentry><term><literal>dll-path</literal></term>
        
        <listitem>
          <simpara>
            Specify a path where dynamic libraries should be found at
            where executable or shared library is run. This feature
            directly affects binaries with the gcc compiler, allowing them
            to pick specific libraries, and ignoring all environment
            settings. On other toolsets, the binary still requires proper
            environment settings to be run. However, Boost.Build tools
            which run executables will notice dll-path settings and create
            this environment automatically.
          </simpara>
        </listitem></varlistentry>
      
      <varlistentry><term><literal>hardcode-dll-paths</literal></term>
        
        <listitem>
          <simpara>
            Controls automatic generation of dll-path properties.
          </simpara>
          
          <para><emphasis role="bold">Allowed values:</emphasis> <literal>off</literal>, <literal>on</literal> When this
            property is on, usage requirements for each library will
            include additional dll-path propertry, with the path the the
            generated library file. This allows to run executables
            without placing all the dependent libraries to a single
            location.</para>
        </listitem></varlistentry>
    </variablelist>
  </section>

  <section id="bbv2.advanced.differences_to_v1">
    <title>Differences to Boost.Build V1</title>

    <para>While Boost.Build V2 is based on the same ideas as Boost.Build V1,
    some of the syntax was changed, and some new important features were
    added. This chapter describes most of the changes.</para>

    <section id="bbv2.advanced.differences_to_v1.configuration">
      <title>Configuration</title>
      
      <para>In V1, there were two methods to configure a toolset. One is to
      set some environment variable, or use "-s" command line option to set
      variable inside BJam. Another method was creating new toolset module,
      which would set the variables and then invoke basic toolset. Neither
      method is necessary now, the "using" rule provides a consistent way to
      initialize toolset, including several versions. See <link
      linkend="bbv2.advanced.configuration">section on configuraton</link> for
      details.
      </para>
      
    </section>

    <section id="bbv2.advanced.differences_to_v1.jamfiles">
      <title>Writing Jamfiles</title>

      <para>Probably one of the most important differences in V2 Jamfiles is
      the project requirements. In V1, if several targets have the same
      requirements (for example, common include path), it was necessary to
      manually write that requirements, or use a helper rule. In V2, the
      common properties can be specified with the "requirements" project
      attribute, as documented <link linkend="bbv2.advanced.projects">here</link>.
      </para>

      <para>The <link linkend="bbv2.tutorial.libs">usage requirements</link>
      is also important mechanism to simplify Jamfile. If a library requires
      all clients to use specific includes, or macroses when compiling the
      code which depends on the library, this information can be cleanly
      represented.</para>

      <para>The difference between "lib" and "dll" targets in V1 is completely
      eliminated in V2. There's only one target -- "lib", which can create
      either static or shared library depending on the value of the 
        <link linkend="bbv2.advanced.builtins.features.link">&lt;link&gt;
      feature</link>. If your target should be only build in one variant, you
      can add &lt;link&gt;shared or &lt;link&gt;static to requirements.
      </para>

      <para>The syntax for referring to other targets was changed a bit. While
      in V1 one would use:
<programlisting>
exe a : a.cpp &lt;lib&gt;../foo/bar ;
</programlisting> 
        the V2 syntax is:
<programlisting>
exe a : a.cpp ../foo//bar ;
</programlisting>
        Note that you don't need to specify the type of other target, but the
        last element should be separated to double slash, to indicate that
        you're referring to target "bar" in project "../foo", and not to
        project "../foo/bar".
        </para>
      
                  
    </section>

    <section id="bbv2.advanced.differences_to_v1.build_process">
      <title>Build process</title>

      <para>The command line syntax in V2 is completely different. For example
<programlisting>
bjam -sTOOLS=msvc -sBUILD=release some_target
</programlisting>
        now becomes:
<programlisting>
bjam toolset=msvc variant=release some_target
</programlisting>
        or, using shortcuts, just:
<programlisting>
bjam msvc release some_target
</programlisting>
      See <link linkend="bbv2.reference.commandline">the reference</link> for
      complete description of the syntax.
      </para>

            
    </section>

  </section>
    

  </chapter>

<!--
     Local Variables:
     mode: xml
     sgml-indent-data: t     
     sgml-parent-document: ("userman.xml" "chapter")
     sgml-set-face: t
     End:
-->

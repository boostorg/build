# Get the recursive Jam invocation code
include recursive.jam ;
include assert-equal.jam ;

Jam "include check-bindrule.jam ;"
    : "found: file-to-bind at subdir1$(SLASH)file-to-bind"
    ;

include check-arguments.jam ;

if $(NT)
{
    # if this one fails, you don't have the line length patch
    Jam "include test_nt_line_length.jam ;" ;
}

# Check that unmatched subst returns an empty list
assert-equal # nothing
    : SUBST "abc" "d+" x ;

# Check that a matched subst works
assert-equal x
    : SUBST "ddd" "d+" x ;
    
# Check that we can get multiple substitutions from a single invocation
assert-equal x y x-y
    : SUBST "x/y/z" "([^/]*)/([^/]*).*" "\\1" $2 "\\1-\\2" ;

#
# test local foreach modification
#
{
    local x = 0 ;
    local entered = ;
    for local x in a b c # x declared local to for loop.
    {
        entered = 1 ;
        if ! ( $(x) in a b c )
        {
            EXIT "local foreach: expected one of a, b, c; got" $(x) ;
        }
    }
    
    if $(x) != 0 # if x was modified, it failed to be a local variable
    {
        EXIT "local foreach failed" ;
    }
}

#
# test while loops
#
{
    local x = a b c ;
    local y = $(x) ;
    local z = ;
    
    while $(y)
    {
        z += $(y[1]) ;
        y = $(y[2-]) ;
    }
    
    if $(z) != $(x)
    {
        EXIT "while loops failed" ;
    }
}

#
# test negative list indices and slices
#
{
    local x = a b c d e ;
    
    rule assert-index ( index : list * )
    {
        if $(x[$(index)]) != $(list)
        {
            ECHO with x= $(x) ;
            ECHO x[$(index)] == $(x[$(index)]) ;
            EXIT expected $(list) ;
        }
    }
    
    assert-index 1 : a ;
    assert-index 3 : c ;
    assert-index 1-2 : a b ;
    assert-index -1 : e ;
    assert-index -2 : d ;
    assert-index 2--2 : b c d ;
    assert-index -3--2 : c d ;
}

# a little utility for assertions
rule identity ( list * )
{
    return $(list) ;
}

#
# test module primitives
#
{
    local x = a b c d e f g h i j ;
    local y = $(x[3-]) ;

    rule shift1 ( dummy ) { }

    module my_module
    {
        module local w y ;
        module local x2 x3 z = 1 2 3 ;

        module local x3 ; # should reset x3
        
        rule shift1 ( )
        {
            x = $(x[2-]) ;
            y = $(z[1]) $(y) ;
            z = $(z[2-]) ;
        }

        rule shift2 ( )
        {
            shift1 ;
        }
        
        shift1 ;
        shift2 ;

        rule get ( symbol )
        {
            return $($(symbol)) ;
        }
    }
    
    my_module.shift1 ;
    y = $(y[2-]) ;
    assert-equal $(x) : identity $(y) ;

    # check module locals
    assert-equal : my_module.get w ;
    assert-equal 3 2 1 : my_module.get y ;
    assert-equal 1 2 3 : my_module.get x2 ;
    assert-equal : my_module.get x3 ;
    assert-equal : my_module.get z ;
    
    my_module.shift2 ;
    y = $(y[2-]) ;
    assert-equal $(x) : identity $(y) ;

    # Prove that the module's rule is not exposed to the world at large without
    # qualification
    shift1 nothing ;
    assert-equal $(x) : identity $(y) ;

    IMPORT : my_module : shift1 shift2 : shifty ;

    shifty ;
    y = $(y[2-]) ;
    assert-equal $(x) : identity $(y) ;

    shift2 ;
    y = $(y[2-]) ;
    assert-equal $(x) : identity $(y) ;


    IMPORT : my_module ;

    shift1 ;
    y = $(y[2-]) ;
    assert-equal $(x) : identity $(y) ;

    shift2 ;
    y = $(y[2-]) ;
    assert-equal $(x) : identity $(y) ;
}

#
# test CALLER_MODULE
#
{
    module module1
    {
        rule f ( )
        {
            local m = [ CALLER_MODULE ] ;
            assert-equal : identity $(m) ;
            module2.f ;
        }

    }
    module module2
    {
        rule f ( )
        {
            local m = [ CALLER_MODULE ] ;
            assert-equal module1 : identity $(m) ;
        }
    }
    module1.f ;
}